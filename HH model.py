# -*- coding: utf-8 -*-
"""Copy of Copy of draft.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17aJF_FBLwMKmF_M9wD-XhQNgsudhyhV0
"""

####this is for a general system of lattice sites
#### without restricting the total number of bosons
import numpy as np
from scipy.linalg import eigh
from scipy.sparse import kron, identity, csr_matrix

# ------------------
# Parameters
# ------------------
t = 1.0
U = 10.0
g = 1.0
omega_0 = 10.0
N_sites = 3  # Can be changed to any L
N_ph = 2
N_el =  N_sites  # Fill all orbitals
max_iter = 100
tol = 1e-6

# ------------------
# Helper: Local phonon Hamiltonian
# ------------------
def boson_matrix(n_avg):
    b_dim = N_ph
    b_plus_b = np.zeros((b_dim, b_dim))
    for n in range(b_dim - 1):
        val = np.sqrt(n + 1)
        b_plus_b[n, n + 1] = val
        b_plus_b[n + 1, n] = val
    n_op = np.diag(np.arange(b_dim))
    return omega_0 * n_op + g * n_avg * b_plus_b

# ------------------
# Initialization
# ------------------
n_up = np.array([0.1] * N_sites)
n_down = np.array([0.1] * N_sites)
b_avg = np.zeros(N_sites)

# ------------------
# Self-consistent loop
# ------------------
for iteration in range(max_iter):
    n_up_old = n_up.copy()
    n_down_old = n_down.copy()
    b_avg_old = b_avg.copy()

    # --- Step 1: Electronic Hamiltonian
    dim_el = 2 * N_sites
    H_el = np.zeros((dim_el, dim_el))
    for i in range(N_sites):
        H_el[2*i, 2*i] = U * n_down[i] + g * b_avg[i]  # up
        H_el[2*i+1, 2*i+1] = U * n_up[i] + g * b_avg[i]  # down

    for i in range(N_sites - 1):  # nearest-neighbor hopping
        H_el[2*i, 2*(i+1)] = H_el[2*(i+1), 2*i] = -t  #up
        H_el[2*i+1, 2*(i+1)+1] = H_el[2*(i+1)+1, 2*i+1] = -t   #down

    eigvals_el, eigvecs_el = eigh(H_el)
    print(eigvals_el)

    # Occupation numbers
    n_up[:] = 0
    n_down[:] = 0
    E_el = 0.0
    for k in range(N_el):
        v = eigvecs_el[:, k]
        E_el += eigvals_el[k]
        for i in range(N_sites):
            n_up[i] += np.abs(v[2*i])**2
            n_down[i] += np.abs(v[2*i+1])**2

    # --- Step 2: Phonon Hamiltonian
    H_ph = csr_matrix((N_ph**N_sites, N_ph**N_sites))
    for i in range(N_sites):
        n_tot = n_up[i] + n_down[i]
        H_local = boson_matrix(n_tot)
        op_list = [identity(N_ph)] * N_sites
        op_list[i] = csr_matrix(H_local)
        H_i = op_list[0]
        for op in op_list[1:]:
            H_i = kron(H_i, op, format='csr')
        H_ph += H_i

    eigvals_ph, eigvecs_ph = eigh(H_ph.toarray())
    psi_ph = eigvecs_ph[:, 0]
    E_ph = eigvals_ph[0]

    # --- Step 3: b_avg expectation values
    b_avg[:] = 0.0
    b_plus_b_local = np.zeros((N_ph, N_ph))
    for n in range(N_ph - 1):
        val = np.sqrt(n + 1)
        b_plus_b_local[n, n + 1] = val
        b_plus_b_local[n + 1, n] = val

    for i in range(N_sites):
        op_list = [identity(N_ph)] * N_sites
        op_list[i] = csr_matrix(b_plus_b_local)
        B_i = op_list[0]
        for op in op_list[1:]:
            B_i = kron(B_i, op, format='csr')
        b_avg[i] = psi_ph.conj().T @ B_i.toarray() @ psi_ph

    # --- Convergence check
    delta_n = np.max(np.abs(n_up - n_up_old)) + np.max(np.abs(n_down - n_down_old))
    delta_b = np.max(np.abs(b_avg - b_avg_old))
    if delta_n < tol and delta_b < tol:
        break

# ------------------
# Energies
# ------------------
E_g_correc = -g * np.sum((n_up + n_down) * b_avg)
E_U_correc = -U * np.sum(n_up * n_down)
E_total = E_el + E_ph + E_g_correc + E_U_correc

# ------------------
# Output
# ------------------
print("\nConverged Mean-Field Results:")
for i in range(N_sites):
    print(f"Site {i}: n_up = {n_up[i]:.6f}, n_down = {n_down[i]:.6f}, b_avg = {b_avg[i]:.6f}")

print("\nEnergies:")
print(f"E_el     = {E_el:.6f}")
print(f"E_ph     = {E_ph:.6f}")
print(f"E_g_correc  = {E_g_correc:.6f}")
print(f"E_U_correc  = {E_U_correc:.6f}")
print(f"E_total  = {E_total:.6f}")

###for fixed phonon number
import numpy as np
from itertools import product
from scipy.linalg import eigh

# ----------------------------
# Parameters
# ----------------------------
t = 1.0
U = 10.0
g = 1.0
omega_0 = 10.0
N_sites = 5
N_el = N_sites
max_total_bosons = 3
N_ph_local = 3   # local basis size for generating restricted states
max_iter = 100
tol = 1e-6

# ----------------------------
# Helper: Phonon basis and operators
# ----------------------------
def generate_phonon_basis_max(N_sites, N_ph_local, max_bosons):
    """Generate phonon basis states with total number of bosons <= max_bosons."""
    all_states = list(product(range(N_ph_local), repeat=N_sites))
    return [state for state in all_states if sum(state) <= max_bosons]

def local_ops(dim):
    """Return local number operator and (b + bâ€ ) operator."""
    b = np.zeros((dim, dim))
    for n in range(1, dim):
        b[n - 1, n] = np.sqrt(n)
    b_dag = b.T
    return np.diag(np.arange(dim)), b + b_dag

def build_operator_on_basis(basis, local_op, site):
    """Build operator acting only on given site in the restricted basis."""
    dim = len(basis)
    op = np.zeros((dim, dim))
    for i, bi in enumerate(basis):
        for j, bj in enumerate(basis):
            if all(bi[k] == bj[k] for k in range(len(bi)) if k != site):
                ni, nj = bi[site], bj[site]
                op[i, j] = local_op[ni, nj]
    return op

# ----------------------------
# Initialization
# ----------------------------
n_up = np.array([0.1] * N_sites)
n_down = np.array([0.1] * N_sites)

# ----------------------------
# Self-consistent loop
# ----------------------------
for iteration in range(max_iter):
    n_up_old = n_up.copy()
    n_down_old = n_down.copy()

    # Step 1: Electronic Hamiltonian
    dim_el = 2 * N_sites
    H_el = np.zeros((dim_el, dim_el))
    for i in range(N_sites):
        H_el[2*i, 2*i] = U * n_down[i]
        H_el[2*i+1, 2*i+1] = U * n_up[i]
    for i in range(N_sites - 1):
        H_el[2*i, 2*(i+1)] = H_el[2*(i+1), 2*i] = -t
        H_el[2*i+1, 2*(i+1)+1] = H_el[2*(i+1)+1, 2*i+1] = -t

    eigvals_el, eigvecs_el = eigh(H_el)

    n_up[:] = 0
    n_down[:] = 0
    E_el = 0.0
    for k in range(N_el):
        v = eigvecs_el[:, k]
        E_el += eigvals_el[k]
        for i in range(N_sites):
            n_up[i] += np.abs(v[2*i])**2
            n_down[i] += np.abs(v[2*i+1])**2

    # Step 2: Phonon Hamiltonian
    basis = generate_phonon_basis_max(N_sites, N_ph_local, max_total_bosons)
    basis_size = len(basis)
    n_op_local, b_plus_b_local = local_ops(N_ph_local)

    H_ph = np.zeros((basis_size, basis_size))
    b_plus_b_ops = []

    for i in range(N_sites):
        n_tot = n_up[i] + n_down[i]
        H_ph += omega_0 * build_operator_on_basis(basis, n_op_local, i)
        H_ph += g * n_tot * build_operator_on_basis(basis, b_plus_b_local, i)
        b_plus_b_ops.append(build_operator_on_basis(basis, b_plus_b_local, i))

    eigvals_ph, eigvecs_ph = eigh(H_ph)
    psi_ph = eigvecs_ph[:, 0]
    E_ph = eigvals_ph[0]

    b_avg = np.array([psi_ph.conj().T @ b_op @ psi_ph for b_op in b_plus_b_ops])

    # Step 3: Update H_el with new b_avg
    for i in range(N_sites):
        H_el[2*i, 2*i] = U * n_down[i] + g * b_avg[i]
        H_el[2*i+1, 2*i+1] = U * n_up[i] + g * b_avg[i]

    delta_n = np.max(np.abs(n_up - n_up_old)) + np.max(np.abs(n_down - n_down_old))
    if delta_n < tol:
        break

# ----------------------------
# Final Energies
# ----------------------------
E_g_correc = -g * np.sum((n_up + n_down) * b_avg)
E_U_correc = -U * np.sum(n_up * n_down)
E_total = E_el + E_ph + E_g_correc + E_U_correc

# ----------------------------
# Output
# ----------------------------
print("\nConverged Mean-Field Results:")
for i in range(N_sites):
    print(f"Site {i}: n_up = {n_up[i]:.6f}, n_down = {n_down[i]:.6f}, b_avg = {b_avg[i]:.6f}")

print("\nEnergies:")
print(f"E_el        = {E_el:.6f}")
print(f"E_ph        = {E_ph:.6f}")
print(f"E_g_correc  = {E_g_correc:.6f}")
print(f"E_U_correc  = {E_U_correc:.6f}")
print(f"E_total     = {E_total:.6f}")

print("\nPhonon Basis States Used (max total bosons = 2):")
for state in basis:
    print(state)